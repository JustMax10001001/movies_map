"""
Module for generating movie map.

Github:
https://github.com/ch1pkav/movie_map
"""

from re import findall
from tqdm import tqdm
from haversine import haversine
from time import time
from geopy.exc import GeocoderUnavailable, GeocoderTimedOut
from geopy.geocoders import Nominatim
from random import shuffle, random
import folium


def user_input() -> tuple:
    """
    Get input from the user. Takes no arguments. Returns tuple of (year, coordinates, execution time)
    """
    year = input("Enter year..")

    user_coords = tuple(map(float, input("Enter desired coordinates (format: lat lng)..").split()))

    print("Longer execution time yelds more precise results.")
    exec_time = input("Enter desired execution time (sec)(default is 150)..")
    if exec_time!="":
        exec_time = int(exec_time)
    else:
        exec_time = 150

    print("Generating {year}_movies_map.html, ETA: {exec_time} secs..".format(year=year, exec_time=exec_time))

    return (year,user_coords,exec_time)


def file_filter(year: str) -> list:
    """
    Scans locations.list for movies released in the given year and returns them as a simple list of strings.
    """
    f = open("locations.list", "r", encoding="latin1")
    movies= f.readlines()[14:-1]
    f.close()

    filtered_movies = []
    for row in movies:
        matches = findall("\((\d{4})\)", row)
        if year in matches:
            filtered_movies.append(row)

    return filtered_movies


def resolve_location_name(row) -> str:
    """
    Auxiliary function to resolve location name from a row of locations.list split by tabs.

    >>> resolve_location_name(['":20 Minute Workout" (1983)', '', '', '', 'Toronto, Ontario, Canada\n'])
    'Toronto, Ontario, Canada'
    """
    #If statement necessary because sometimes there is extra 
    #explanation after the location name in the movie database.
    if row[-1][0] == "(":
        location_name = row[-2]
    else:
        location_name = row[-1][:-1]
    return location_name


def get_coords(movies_list, max_exec_time=150) -> list:
    """
    Gets coordinates from the movie list generated by file_filter.
    Returns a neat list of tuples e.g (movie_title, location_name, (latitude, longitude))
    If geopy cannot resolve coordinates, the tuple of (latitude, longitude) will instead be None.
    >>>get_coords(['À nos amours (1983)\t\t\t\t\tHyères, Var, France\n',\
    'Áramótaskaup 1983 (1983) (TV)\t\t\t\tIceland\n',\
    'Éducation anglaise (1983)\t\t\t\tGare, Richelieu, Indre-et-Loire, France\t(Steam train + station)\n',\
    'Întoarcerea Vlasinilor (1983)\t\t\t\tRomania\n'])
    [('À nos amours', 'Hyères, Var, France', (43.1202573, 6.1301614)),\
    ('Áramótaskau', 'Iceland', (64.9841821, -18.1059013)),\
    ('Éducation anglaise', 'Gare, Richelieu, Indre-et-Loire, France', (47.0153793, 0.3185517476888088)),\
    ('Întoarcerea Vlasinilor', 'Romania', (45.9852129, 24.6859225))]
    """

    geolocator = Nominatim(user_agent="ucu_apps_map_maker")

    beginning = time()
    #geopy seems to take very differrent times for differrent locations,
    #making the execution time inconsistent.
    #for user's sake, the default max execution time is 150 seconds.
    #this means that results will be imprecise, but the program is functional.

    coords_list = []

    location_dict = {}
    #implementing a location dictionary because a lot of locations
    #are repeated numerous times within the database.
    unresolved = 0

    shuffle(movies_list)

    for row in tqdm(movies_list):
        title_location_list = []

        split_row = row.split("\t")
        year = findall("\((\d{4})\)", split_row[0])

        #lazily implemented movie name resolution by taking the part of an entry before the release year
        title_location_list.append(split_row[0][:split_row[0].index(year[-1])-2])

        location_name = resolve_location_name(split_row)
        title_location_list.append(location_name)

        try:
            if location_name not in location_dict:
                location = geolocator.geocode(location_name)
                title_location_list.append((location.latitude, location.longitude))
                location_dict[location_name] = (location.latitude, location.longitude)
            else:
                title_location_list.append(location_dict[location_name])

        except (AttributeError, GeocoderUnavailable):
            title_location_list.append(None)
            location_dict[location_name] = None
            unresolved+=1

        coords_list.append(tuple(title_location_list))

        if time() - beginning >= max_exec_time:
            break

    return coords_list

def find_10_closest(coords_list: list, user_coords: tuple) -> list:
    """
    Finds 10 closes locations from coords_list to the specified location (user_coords).
    Result is sorted by distance low to high.

    >>>find_10_closest([('À nos amours', 'Hyères, Var, France', (43.1202573, 6.1301614)),\
    ('Áramótaskau', 'Iceland', (64.9841821, -18.1059013)),\
    ('Éducation anglaise', 'Gare, Richelieu, Indre-et-Loire, France', (47.0153793, 0.3185517476888088)),\
    ('Întoarcerea Vlasinilor', 'Romania', (45.9852129, 24.6859225))], (49.815884499999996, 24.02549565))
    [('Întoarcerea Vlasinilor', 'Romania', (45.9852129, 24.6859225)),\
    ('À nos amours', 'Hyères, Var, France', (43.1202573, 6.1301614)),\
    ('Éducation anglaise', 'Gare, Richelieu, Indre-et-Loire, France', (47.0153793, 0.3185517476888088)),\
    ('Áramótaskau', 'Iceland', (64.9841821, -18.1059013))]
    """
    def sorting(movie):
        """
        Simple auxiliary sorting function.
        """
        if movie[-1]!=None:
            return haversine(movie[-1], user_coords)
        return 100000

    sorted_by_closest = sorted(coords_list, key=sorting)
    return sorted_by_closest[:10]


def generate_map(coords_list: list, user_coords: tuple, year: str) -> None:
    """
    Generates <year>_movies_map.html with 10 markers representing
    filming locations and a marker on user-specified coordinates.
    No output.
    """

    m = folium.Map(location = list(user_coords), zoom_start = 2)

    movie_markers_group = folium.FeatureGroup(name = "Movie markers")
    markers_group = folium.FeatureGroup(name = "Location marker")
    funny_image = folium.FeatureGroup(name = "Image of a cat in a random location", show=False)

    markers_group.add_child(folium.Marker(list(user_coords), tooltip = "You are here!"))

    for entry in coords_list:
        movie_markers_group.add_child(folium.Marker(list(entry[-1]), tooltip = entry[0], popup = entry[1]))

    funny_image.add_child(folium.Marker(((random()-0.5)*90, (random()-0.5)*180),\
        tooltip = "You found the cat.", popup="<img src=https://i.kym-cdn.com/entries/icons/facebook/000/026/638/cat.jpg>"))

    m.add_child(movie_markers_group)
    m.add_child(markers_group)
    m.add_child(funny_image)

    m.add_child(folium.LayerControl())

    m.save("{}_movies_map.html".format(year))

    return None


if __name__ == "__main__":

    year, user_coords, exec_time = user_input()

    movie_list = find_10_closest(get_coords(file_filter(year), max_exec_time=exec_time), user_coords)

    generate_map(movie_list, user_coords=user_coords, year=year)

    print("Done!")
